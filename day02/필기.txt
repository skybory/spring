 1. @Autowired
  - 생성자에 @Autowired가 있으면 스프링이 연관된 객체를 스프링 컨테이너에서 찾아서 넣어준다.
  이렇게 객체 의존 관계를 외부에서 넣어주는 것을 DI(Dependency Injection), 의존성 주입이라고 한다.
  - 이전엔 개발자가 직접 주입했고, @Autowired 에 의해 스프링이 주입해줄 수 있다.

 2. IoC
  - 제어 역전(IoC, Inversion of Control)
  - 개발자가 프레임워크의 기능을 호출하는 형태가 아니라, 프레임워크가 개발자의 코드를 호출하기 때문에, 개발자는
  전체를 직접 구현하지 않고 자신의 코드를 부분적으로 "끼워넣기"하는 형태로 구현할 수 있다.
  이는 개발자로 하여금 구현하고자 하는 특정 분야의 기능에 집중할 수 있도록 한다.
  - 프레임워크가 객체의 생성, 소멸과 같은 라이프 사이클을 관리하며, 스프링으로부터 필요한 객체를 얻어 올 수 도 있다.
  - 객체의 의존성을 역전시켜 객체간의 결합도를 줄이고, 유연한 코드를 작성할 수 있게 하여 가독성 및 코드 중복,
  유지 보수를 편하게 할 수 있게 한다.

 3. 스프링 컨테이너란?
  - 스프링 컨테이너는 자바 객체의 생명 주기를 관리하며, 생성된 자바 객체들에게 추가적인 기능을 제공하는 역할을 한다.
  여기서 말하는 자바 객체를 스프링에서는 빈(Bean)이라고 부른다.
  - 개발자는 객체를 생성하고 소멸할 수 있는데, 스프링 컨테이너가 이 역할을 대신해준다. 즉, 제어의 흐름을 외부에서 관리하는 것이다.
  또한, 객체들 간의 의존 관계를 스프링 컨테이너가 런타임 과정에서 알아서 만들어 준다.
  - 스프링은 실행시 객체들을 담고있는 Container가 있다.

 4. POJO란?
  - Plain Old Java Object, 단순한 자바 오브젝트
  - POJO란, 객체 지향적인 원리에 충실하면서 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를
  말한다. 
  - 그러한 POJO에 애플리케이션의 핵심 로직과 기능을 담아 설계하고 개발하는 방법을 POJO 프로그래밍 이라고 할 수 있다.

 5. DI
  - 의존성 주입
  - Dependency Injection
  - 객체간의 의존성이 존재할 경우 개발자가 직접 객체를 생성하거나 제어하는 것이 아니라, 제어 반전에 의하여
  특정 객체에 필요한 다른 객체를 프레임워크가 자동으로 연결시켜 주는 것을 말한다.
  - 개발자는 자신에게 필요한 객체를 직접 할당하지 않고, 인터페이스를 통해 선언한 객체에 스프링 프레임워크에 의해
  주입받아 사용할 수 있기 때문에 비지니스 로직 개발에만 집중할 수 있다.
  - 개발자는 객체를 선언만 할 뿐, 할당은 프레임워크에 의해서 자동으로 이루어진다.

 6. 컴포넌트 스캔의 대상
  - Component scan 의 대상은 main 메서드가 있는 class의 동일 패키지 또는 하위 패키지만 Spring이 scan을 하는 대상이 된다.
  ( 당연히 추가 설정을 통해서 다른 패키지의 클래스도 대상이 될 수 있다 )

  - 사실은 @ComponentScan 만 선언되어 있으면 읽어오는게 가능하다. 

 7. DI의 3가지 방법
  - Field Injection (필드 주입)
  - Setter Injection (수정자 주입)	
  - Constructor Injection (생성자 주입)	->	이것만 사용 ( 위의 2개는 치명적 단점이 있음 )

 8. db계정생성

 9. DataSource
  - 순수 jdbc로, 데이터 베이스에 접근하면, 데이터베이스에 접근할때마다 Connection을 맺고 끊는 작업을 한다. connection들을 모아두는 장소를 connection pool이라고 하며, Datasource는 java에서 Connection pool을 지원하기 위한 인터페이스이다.


 10. JPA
  - JPA는 기존의 반복 코드는 물론이고, 기본적인 SQL도 JPA가 직접 만들어서 실행해준다.
  - JPA를 사용하면, SQL과 데이터 중심의 설계에서, 객체 중심의 설계로 패러다임을 전환할 수 있다.
  - JPA를 사용하면 개발 생산성을 크게 높일 수 있다.
  - Spring 만큼이나 큰 기술이다.

 11. 클린코드로 유명한 로버트 마틴이 말하는 '좋은 객체 지향 설계의 5가지 원칙' : SOLID 원칙
  - SRP : 단일 책임 원칙 ( Single Responsibility Principle )
  - OCP : 개방-폐쇄 원칙 ( Open/Closed Principle)
  - LSP : 리스코프 치환 원칙 ( Liskov Substitution Principle )
  - ISP : 인터페이스 분리 원칙 ( Interface Segregation Principle )
  - DIP : 의존관계 역전 원칙 ( Dependency Inversion Principle )

 11-1. SRP : 단일 책임 원칙
  - 한 클래스는 하나의 책임만 가져야 한다.
  - 하나의 책임이라는 것은 모호하다.
  - 클 수 있고, 작을 수 있다.
  - 문맥과 상황에 따라 다르다.
  - 중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것.

 11-2. OCP : 개방-폐쇄 원칙
  - 확장에는 열려있고, 수정 및 변경에는 닫혀있다.
  - 스프링의 DI를 사용하면 기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경할 수 있다.

 11-3. LSP : 리스코프 치환 원칙
  - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
  - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것.
  다형성을 지원하기 위한 원칙이며, 인터페이스를 구현한 구현체를 믿고 사용하려면, 이 원칙이 필요하다.

 11-4. ISP : 인터페이스 분리 원칙
  - 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.
  - 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
  - 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않는다.
  - 인터페이스가 명확해지고, 대체 가능성이 높아진다.

 11-5. DIP : 의존관계 역전 원칙
  - "프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다"
  의존성 주입은 이 원칙을 따르는 방법 중 하나다.
  - 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
  - 구현체에 의존하면 변경이 아주 어려워진다.

 