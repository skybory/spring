1. 스프링 인터셉터
 1-1. 스프링 인터셉터란?
  - 스프링 인터셉터도 서블릿 필터와 같이 웹과 관련된 공통 관심사항을 효과적으로 해결할 수 있는 기술이다.
  필터가 서블릿이 제공하는 기술이라면, 스프링 인터셉터는 스프링 MVC가 제공하는 기술이다. 둘 다 웹과 관련된 공통
  관심사항을 처리하지만, 적용되는 순서와 범위, 그리고 사용 방법이 다르다.
  - 필터보다 인터셉터가 더 디테일한 컨트롤이 가능하다.

 1-2. 스프링 인터셉터의 흐름
  - HTTP요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터 -> 컨트롤러
  - 스프링 인터셉터는 디스패처 서블릿과 컨트롤러 사이에서 컨트롤러 호출 직전에 호출된다.
  - 스프링 인터셉터는 스프링 MVC가 제공하는 기능이기 때문에 결국 디스패처 서블릿 이후에 등장하게 된다.
  - 스프링 MVC의 시작점이 디스패처 서블릿이다 라고 생각해보면 이해가 될 것이다.
  - 스프링 인터셉터에도 URL 패턴을 적용할 수 있는데, 서블릿 URL 패턴과는 다르고, 매우 정밀하게 설정할 수 있다.

 1-3. 스프링 인터셉터 제한
// 로그인한 사용자
  - HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터
	-> 컨트롤러

// 비 로그인 사용자
  - HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터
	(적절하지 않은 요청이라 판단, 컨트롤러 호출X)

 1-4. 스프링 인터셉터 체인
  - HTTP 요청 -> WAS -> (필터) -> 인터셉터1 -> 인터셉터2 -> 컨트롤러 
  - 스프링 인터셉터는 체인으로 구성되는데, 중간에 인터셉터를 자유롭게 추가할 수 있다. 예를 들어
  로그를 남기는 인터셉터를 먼저 적용하고, 그 다음에 로그인 여부를 체크하는 인터셉터를 만들 수 있다.
  지금까지 내용울 보면 서블릿 필터와 호출되는 순서만 다르고, 제공하는 기능은 비슷해 보인다.
  스프링 인터셉터는 서블릿 필터보다 편리하고, 더 정교하고 다양한 기능을 지원한다.

 1-5. HandlerInterceptor
  - 스프링의 인터셉터를 사용하려면 HandlerInterceptor 인터페이스를 구현하면 된다.
  - 서블릿 필터의 경우 단순하게 doFilter() 하나만 제공된다.
  - 인터셉터는 컨트롤러 호출 전 (preHandler), 호출 후 (postHandle), 요청 완료 이후(afterCompletion)와 같이 단계적으로
  잘 세분화 되어 있다.
  - 서블릿 필터의 경우 단순히 request, response만 제공했지만, 인터셉터는 어떤 컨트롤러(handler)가 호출되는지
  호출 정보도 받을 수 있다. 그리고 어떤 modelAndView가 반환되는지 응답정보도 받을 수 있다.

 1-6. 정상흐름
  - preHandle : 컨트롤러 호출 전에 호출된다.
  응답값이 true이면 다음으로 진행, false이면 더는 진행하지 않는다.
  false 인 경우 나머지 인터셉터는 물론이고, 핸들러 어댑터도 호출되지 않는다.
  - postHandle : 컨트롤러 호출 후에 호출된다.
  - afterCompletion : 뷰가 랜더링 된 이후에 호출된다.

 1-7. 인터셉터 등록 설명
  - addInterceptors()를 사용해서 인터셉터를 등록할 수 있다.
  - .addInterceptor(new LogInterceptor()) : 인터셉터 등록
  - .order(1) : 호출 순서
  - .addPathPatterns("/**") : 인터셉터를 적용할 URL 패턴을 지정
  - .excludePathPatterns("/css/**","/error") : 인터셉터를 제외할 URL 패턴을 지정
  - 필터와 비교해보면 인터셉터는 addPathPatterns, excludePathPatterns 로 매우 정밀하게 URL 패턴을 정할 수 있다.

  - 2개 이상의 페이지에 대해 중복하여 Interceptor를 쓰려면 addPathPatterns("/sub1/test1", "/sub1/test4") 를 사용한다.

2. JPA
  - Java Persistnce API
  - JPA는 자바 진영에서 ORM ( Object-Relational Mapping )기술 표준으로 사용되는 인터페이스의 모음이다.
  - 그 말은 즉, 실제적으로 구현된것이 아니라 구현된 클래스와 매핑을 해주기 위해 사용되는 프레임워크이다.
  - JPA를 구현한 대표적인 오픈소스로는 Hibernate가 있다.
  - JPA는 표준 인터페이스이고, 구현체는 Hibernate이다.

3. ORM
  - Object-Realational Mapping ( 객체 관계 매핑 )
  - 객체는 객체대로 설계
  - 관계형 데이터베이스 (RDB) 는 관계형 데이터베이스로 설계
  - ORM프레임워크가 중간에서 매핑
  - 대중적인 언어에는 대부분 ORM 기술이 존재
  - 우리가 일반적으로 알고있는 애플리케이션 Class 와 RDB(Realational DataBase)의 테이블을 매핑한다는 뜻이며,
  기술적으로는 어플리케이션의 객체를 RDB 테이블에 자동으로 영속화 해주는 것이라고 보면 된다.

4. JPA 장점
  - SQL문이 아닌 Method를 통해서 DB를 조작할 수 있어, 개발자는 객체 모델을 이용하여 비지니스 로직을 구성하는데만
  집중할 수 있다.
  (내부적으로는 쿼리를 생성하여 DB를 조작함. 하지만 개발자가 이를 신경쓰지 않아도 됨)
  - Query와 같이 필요한 선언문, 할당 등의 부수적인 코드가 줄어들어, 각종 객체에 대한 코드를 별도로 작성하여
  코드의 가독성을 높임.
  - 객체지향적인 코드 작성이 가능하다. 오직 객체지향적 접근만 고려하면 되기 때문에 생산성이 증가
  - 매핑하려는 정보가 Class로 명시되었기 때문에 ERD를 보는 의존도를 낮출 수 있고, 유지보수 및 리팩토링에 유리함
  - 기존 방식에서 MySQL 데이터 베이스를 사용하다가, PostgreSQL로 변환한다고 가정하면, 새로 쿼리를 짜야하는 경우가 생김.
  이런 경우에 ORM을 사용한다면 쿼리를 수정할 필요가 없음

5. JPA 단점
  - 프로젝트의 규모가 크고, 복잡한 설계가 잘못된 경우, 속도 저하 및 일관성을 무너뜨리는 문제점이 생길 수 있다.
  - 복잡하고 무거운 Query는 속도를 위해 별도의 튜닝을 필요로 하기 때문에 결국 SQL문을 써야할 수도 있다.
  - 학습비용 비쌈

6. 데이터베이스 방언
  - JPA는 특정 데이터베이스에 종속X
  - 각각의 데이터베이스가 제공하는 SQL 문법과 함수는 조금씩 다르다.
  - 가변문자 : Oracle 에서는 varchar2, MySQL 에서는 varchar를 사용한다.
  - 문자열을 자르는 함수 : Oracle 에서는 SUBSTR(), SQL표준 에서는 SUBSTRING() 을 사용한다.
  - 방언 : SQL 표준을 지키지 않은 특정 데이터베이스만의 고유한 기능 
  -> Oracle 이라는 사투리를 사용해서 쿼리를 작성해 ~ 라는 개념

7. @Entity
  - 'JPA가 관리할 객체' 라는 선언

8. @Id
  - 데이터베이스 PK와 매핑

9. JPA에서 가장 중요한 2가지
  - 객체와 관계형 데이터베이스 매핑하기
  (Object Relational Mapping)
  - 영속성 컨텍스트

10. 영속성 컨텍스트
  - JPA를 이해하는데 가장 중요한 용어
  - "엔티티를 영구 저장하는 환경"이라는 뜻
  - EntityManager.persist(entity);
	-> entity 객체는 Member, Team, ... 등
	-> 처음부터 DB에 저장하는게 아니라, 영속성 컨텍스트 라는 곳에 저장한다.

11. 영속성 컨텍스트
  - 영속성 컨텍스트는 논리적인 개념
  - 눈에 보이지 않음
  - 엔티티 매니저를 통해 영속성 컨텍스트에 접근
  - EntityManager 를 생성하면 영속성 컨텍스트가 생성됨

12. 엔티티의 생명주기
  - 비영속 (new)
	-> 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
  - 영속 (managed)
	-> 영속성 컨텍스트에 관리되는 상태
  - 준영속 (detached)
	-> 영속성 컨텍스트에 저장되었다가 분리된 상태
  - 삭제 (removed)
	-> 삭제된 상태

13. 비영속 - JPA와 전혀 상관 없는 상태
  //객체를 생성한 상태(비영속)
  Member member = new Member();
  member.setId("member1");
  member.setUsername("회원1");

14. 영속 - JPA에 속해있는 상태
  //객체를 생성한 상태(비영속)
  Member member = new Member();
  member.setId("member1");
  member.setUsername("회원1");

  EntityManagerFactory emf = new EntityManagerFactory();
  EntityManager em = emf.createEntityManager();
  em.getTransaction().begin();

  // 객체를 저장한 상태(영속)
  em.persist(member);

  tx.commit();	// 이 시점에 DB insert가 날아감

 15. 준영속
  // 회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태
  em.detach(member);		// 주로 명시할 일이 없음

 16. 삭제
  // 객체 삭제를 요청한 상태
  em.remove(member);





















































